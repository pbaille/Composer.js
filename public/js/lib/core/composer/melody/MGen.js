// Generated by CoffeeScript 1.6.3
(function() {
  var __hasProp = {}.hasOwnProperty,
    __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; };

  define(["lib/core/base/Domain", "lib/utils/Combinatorics", "lib/core/composer/melody/MelodicPatternGen", "vendors/ruby"], function() {
    var Domain, DomainPartition, MelodicPatternGen, Mode, Pitch, root;
    if (typeof global !== "undefined" && global !== null) {
      root = global.AC.Core;
    } else {
      root = window.AC.Core;
    }
    Domain = AC.Core.Domain;
    Mode = AC.Core.Mode;
    Pitch = AC.Core.Pitch;
    DomainPartition = AC.Utils.DomainPartition;
    MelodicPatternGen = AC.Core.MelodicPatternGen;
    return root.MGen = (function(_super) {
      __extends(MGen, _super);

      function MGen(opt) {
        if (!opt) {
          opt = {};
        }
        MGen.__super__.constructor.call(this, {
          mode: opt.mode || new Mode("C Lyd"),
          bounds: opt.bounds || [50, 80]
        });
        this.current_pitch = opt.current_pitch || this.pitches[opt.current_index] || _a.pick_random_el(this.pitches);
        this.current_index = opt.current_index || this.pitches.indexOf(this.current_pitch);
        this.melodicPatternGen = new MelodicPatternGen({
          steps_array: [-3, -1, 1, 3],
          iterations: [1, 2, 3],
          cycle_step: [-3, -2, -1, 1, 2, 3],
          pattern_length: [2, 3, 4]
        });
        if (opt.strategy) {
          this[opt.strategy.name].apply(this, opt.strategy.args);
        } else {
          this.step_pattern2();
        }
        this.composer = null;
      }

      MGen.prototype.melodize = function(positioned_rvals_arr) {
        var line, n, pitch, pos_rval, vel, _i, _len;
        line = [];
        for (_i = 0, _len = positioned_rvals_arr.length; _i < _len; _i++) {
          pos_rval = positioned_rvals_arr[_i];
          pitch = this.next();
          vel = 60;
          n = new AC.Core.Note(pitch.value, vel, pos_rval.rval, pos_rval.position);
          line.push(n);
        }
        return line;
      };

      MGen.prototype.set_current_pitch = function(pitch) {
        var pitches;
        if (!(pitch instanceof Pitch)) {
          pitch = new Pitch(pitch);
        }
        pitches = this.pitches.slice(0);
        pitches.sort(function(a, b) {
          return Math.abs(a.dist_to(b));
        });
        this.current_pitch = pitches[0];
        return this.current_index = this.pitches.indexOf(this.current_pitch);
      };

      MGen.prototype.step = function(n) {
        var new_index;
        new_index = this.current_index + n;
        if (this.pitches[new_index]) {
          this.current_index = new_index;
          this.current_pitch = this.pitches[new_index];
          return true;
        } else {
          return false;
        }
      };

      MGen.prototype.bounds_from_current_pitch = function() {
        return [this.current_index * -1, this.pitches.length - this.current_index - 1];
      };

      MGen.prototype.step_pattern = function(step_sequence, cycle_step, iterations) {
        var counter, done_count, invert, seq_total_step,
          _this = this;
        seq_total_step = _a.somme(step_sequence);
        step_sequence.push(seq_total_step * -1 + cycle_step);
        counter = -1;
        done_count = step_sequence.length * iterations;
        invert = function() {
          return step_sequence = step_sequence.map(function(x) {
            return x * -1;
          });
        };
        return this.next = function() {
          if (_this.step(step_sequence[0])) {
            counter++;
            if (counter === 0) {
              return _this.current_pitch;
            }
            if (counter < done_count) {
              step_sequence = _a.rotate(step_sequence, 1);
              return _this.current_pitch;
            } else {
              _this.strat_done();
              return _this.current_pitch;
            }
          } else {
            invert();
            return _this.next();
          }
        };
      };

      MGen.prototype.step_pattern2 = function(melodicPattern) {
        var _this = this;
        if (!melodicPattern) {
          melodicPattern = this.melodicPatternGen.give_pattern(this.bounds_from_current_pitch());
        }
        return this.next = function() {
          var step;
          step = melodicPattern.next();
          if (step) {
            if (_this.step(step)) {
              return _this.current_pitch;
            } else {
              _this.step_pattern2(_this.melodicPatternGen.give_pattern(_this.bounds_from_current_pitch()));
              return _this.next();
            }
          } else {
            _this.step_pattern2(_this.melodicPatternGen.give_pattern(_this.bounds_from_current_pitch()));
            return _this.next();
          }
        };
      };

      MGen.prototype.drunk = function(min, max, rep) {
        var _this = this;
        if (rep == null) {
          rep = false;
        }
        return this.next = function() {
          var arr, s, zero_index, _i, _results;
          while (_this.current_index + min < 0) {
            min++;
          }
          while (_this.current_index + max >= _this.pitches.length) {
            max--;
          }
          arr = (function() {
            _results = [];
            for (var _i = min; min <= max ? _i <= max : _i >= max; min <= max ? _i++ : _i--){ _results.push(_i); }
            return _results;
          }).apply(this);
          if (!rep) {
            zero_index = arr.indexOf(0);
            arr.splice(zero_index, 1);
          }
          s = _a.pick_random_el(arr);
          _this.step(s);
          return _this.current_pitch;
        };
      };

      MGen.prototype.interval_prob_array = function(prob_array) {
        var _this = this;
        return this.next = function() {
          var e, pioche, x, _i, _j, _len, _ref;
          pioche = [];
          for (_i = 0, _len = prob_array.length; _i < _len; _i++) {
            e = prob_array[_i];
            if (e.occ && _this.pitches[_this.current_index + e.step]) {
              for (x = _j = 1, _ref = e.occ; 1 <= _ref ? _j <= _ref : _j >= _ref; x = 1 <= _ref ? ++_j : --_j) {
                pioche.push(e.step);
              }
            } else if (_this.pitches[_this.current_index + e]) {
              pioche.push(e);
            }
          }
          _this.step(_a.pick_random_el(pioche));
          return _this.current_pitch;
        };
      };

      MGen.prototype.random_pitch = function() {
        return _a.pick_random_el(this.pitches);
      };

      return MGen;

    })(Domain);
  });

}).call(this);
