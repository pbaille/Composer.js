// Generated by CoffeeScript 1.6.3
(function() {
  var __hasProp = {}.hasOwnProperty,
    __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
    __slice = [].slice;

  define(["lib/core/base/Domain", "lib/utils/Combinatorics", "lib/utils/Module", "lib/core/composer/melody/MelodicPatternGen", "lib/core/composer/melody/PassingTones", "vendors/ruby"], function() {
    var Domain, DomainPartition, MelodicPatternGen, Mode, Module, PassingTones, Pitch, root;
    if (typeof global !== "undefined" && global !== null) {
      root = global.AC.Core;
    } else {
      root = window.AC.Core;
    }
    Domain = AC.Core.Domain;
    Mode = AC.Core.Mode;
    Pitch = AC.Core.Pitch;
    DomainPartition = AC.Utils.DomainPartition;
    MelodicPatternGen = AC.Core.MelodicPatternGen;
    PassingTones = AC.Core.PassingTones;
    Module = AC.Utils.Module;
    return root.MGen = (function(_super) {
      __extends(MGen, _super);

      function MGen(opt) {
        if (opt == null) {
          opt = {};
        }
        MGen.__super__.constructor.call(this, opt);
        this.current_pitch = opt.current_pitch || this.pitches[opt.current_index] || _a.pick_random_el(this.pitches);
        this.current_index = opt.current_index || this.pitches.indexOf(this.current_pitch);
        this.melodicPatternGen = new MelodicPatternGen({
          steps_array: [-4, -3, -2, -1, 1, 2, 3, 4],
          iterations: [2, 3, 4],
          cycle_step: [-7, -6, -5, -4, -3, -2, -1, 1, 2, 3, 4, 5, 6, 7],
          pattern_length: [2, 3, 4, 5, 6]
        });
        if (opt.strategy) {
          this[opt.strategy.name].apply(this, opt.strategy.args);
        } else {
          this.step_pattern2();
        }
        this.composer = null;
      }

      MGen.prototype.melodize = function(positioned_rvals_arr) {
        var line, n, pitch, pos_rval, vel, _i, _len;
        line = [];
        for (_i = 0, _len = positioned_rvals_arr.length; _i < _len; _i++) {
          pos_rval = positioned_rvals_arr[_i];
          pitch = this.next();
          vel = 60;
          n = new AC.Core.Note(pitch.value, vel, pos_rval.rval, pos_rval.position);
          line.push(n);
        }
        return line;
      };

      MGen.prototype.set_current_pitch = function(pitch) {
        if (!(pitch instanceof Pitch)) {
          pitch = new Pitch(pitch);
        }
        pitch = this.find_closest_pitch_from(pitch);
        this.current_index = this.indexOf(pitch);
        return this.current_pitch = this.pitches[this.current_index];
      };

      MGen.prototype.get_current_degree = function() {
        var i, pci, pitch_class_int, _i, _len, _ref;
        pitch_class_int = this.current_pitch.value % 12;
        _ref = this.available_concrete();
        for (i = _i = 0, _len = _ref.length; _i < _len; i = ++_i) {
          pci = _ref[i];
          if (pci === pitch_class_int) {
            return this.available_degrees_array()[i];
          }
        }
        throw "get_current_degree can't find degree :s weird!";
      };

      MGen.prototype.set_melodic_context = function(mode, degrees_functions) {
        MGen.__super__.set_melodic_context.call(this, mode, degrees_functions);
        return this.set_current_pitch(this.find_closest_pitch_from(this.current_pitch));
      };

      MGen.prototype.find_closest_pitch_from = function(pitch) {
        var i, intervals, min, pval, _i, _len, _ref;
        intervals = [];
        _ref = this.pitches_values();
        for (i = _i = 0, _len = _ref.length; _i < _len; i = ++_i) {
          pval = _ref[i];
          intervals.push(Math.abs(pitch.value - pval));
        }
        min = Math.min.apply(Math, intervals);
        return this.pitches[intervals.indexOf(min)];
      };

      MGen.prototype.step = function(n) {
        var new_index;
        new_index = this.current_index + n;
        if (this.pitches[new_index]) {
          this.current_index = new_index;
          this.current_pitch = this.pitches[new_index];
          return true;
        } else {
          return false;
        }
      };

      MGen.prototype.bounds_from_current_pitch = function() {
        return [this.current_index * -1, this.pitches.length - this.current_index - 1];
      };

      MGen.prototype.strategy_is_done = function() {
        var args;
        args = 1 <= arguments.length ? __slice.call(arguments, 0) : [];
        return console.log("strategy is done");
      };

      MGen.prototype.step_pattern = function(step_sequence, cycle_step, iterations) {
        var counter, done_count, invert, seq_total_step,
          _this = this;
        seq_total_step = _a.somme(step_sequence);
        step_sequence.push(seq_total_step * -1 + cycle_step);
        counter = -1;
        done_count = step_sequence.length * iterations;
        invert = function() {
          return step_sequence = step_sequence.map(function(x) {
            return x * -1;
          });
        };
        return this.next = function() {
          if (_this.step(step_sequence[0])) {
            counter++;
            if (counter === 0) {
              return _this.current_pitch;
            }
            if (counter < done_count) {
              step_sequence = _a.rotate(step_sequence, 1);
              return _this.current_pitch;
            } else {
              _this.strat_done();
              return _this.current_pitch;
            }
          } else {
            invert();
            return _this.next();
          }
        };
      };

      MGen.prototype.step_pattern2 = function(melodicPattern) {
        var _this = this;
        if (!melodicPattern) {
          melodicPattern = this.melodicPatternGen.give_pattern(this.bounds_from_current_pitch());
        }
        return this.next = function() {
          var step;
          step = melodicPattern.next();
          if (step) {
            if (_this.step(step)) {
              return _this.current_pitch;
            } else {
              throw "out of bounds!! means that MelodicPatternGen#give_pattern doesn't works well";
            }
          } else {
            _this.step_pattern2();
            return _this.next();
          }
        };
      };

      MGen.prototype.drunk = function(min, max, rep) {
        var _this = this;
        if (rep == null) {
          rep = false;
        }
        return this.next = function() {
          var arr, zero_index, _i, _max, _min, _results;
          _min = min;
          _max = max;
          while (_this.current_index + _min < 0) {
            _min++;
          }
          while (_this.current_index + _max >= _this.pitches.length) {
            _max--;
          }
          arr = (function() {
            _results = [];
            for (var _i = _min; _min <= _max ? _i <= _max : _i >= _max; _min <= _max ? _i++ : _i--){ _results.push(_i); }
            return _results;
          }).apply(this);
          if (!rep) {
            zero_index = arr.indexOf(0);
            arr.splice(zero_index, 1);
          }
          _this.step(_a.sample(arr));
          return _this.current_pitch;
        };
      };

      MGen.prototype.interval_prob_array = function(prob_array) {
        var _this = this;
        return this.next = function() {
          var e, pioche, x, _i, _j, _len, _ref;
          pioche = [];
          for (_i = 0, _len = prob_array.length; _i < _len; _i++) {
            e = prob_array[_i];
            if (e.occ && _this.pitches[_this.current_index + e.step]) {
              for (x = _j = 1, _ref = e.occ; 1 <= _ref ? _j <= _ref : _j >= _ref; x = 1 <= _ref ? ++_j : --_j) {
                pioche.push(e.step);
              }
            } else if (_this.pitches[_this.current_index + e]) {
              pioche.push(e);
            }
          }
          _this.step(_a.pick_random_el(pioche));
          return _this.current_pitch;
        };
      };

      MGen.prototype.random_pitch = function() {
        return _a.sample(this.pitches);
      };

      MGen.prototype.drunk_passing = function(passing_size, broderie) {
        var dist_from_target_array,
          _this = this;
        if (broderie == null) {
          broderie = false;
        }
        dist_from_target_array = [];
        return this.next = function() {
          var degree, passing_set, pitch, pitch_val;
          if (dist_from_target_array.length === 0) {
            _this.set_current_pitch(_a.sample(_this.main_pitches));
            degree = _this.get_current_degree();
            passing_set = _a.sample(profile.passing_combinations[passing_size]);
            passing_set = _a.scramble(passing_set);
            passing_set.push("self");
            if (broderie) {
              passing_set = ["self"].concat(passing_set);
            }
            dist_from_target_array = _this.passing_set_to_dist_from_target_array(degree, passing_set);
          }
          pitch_val = _this.current_pitch.value + dist_from_target_array.splice(0, 1)[0];
          pitch = new Pitch(pitch_val);
          return pitch;
        };
      };

      MGen.prototype.simple_passing = function(target, passing_set) {
        var degree, dist_from_target_array,
          _this = this;
        degree = this.get_current_degree();
        dist_from_target_array = this.passing_set_to_dist_from_target_array(degree, passing_set);
        return this.next = function() {
          var pitch_val;
          if (dist_from_target_array.length === 0) {
            return _this.strategy_is_done();
          } else {
            pitch_val = _this.current_pitch.value + dist_from_target_array.splice(0, 1)[0];
            return new Pitch(pitch_val);
          }
        };
      };

      return MGen;

    })(Domain);
  });

}).call(this);
