// Generated by CoffeeScript 1.6.3
(function() {
  var __slice = [].slice;

  define(["lib/Rational", "lib/Note", "lib/play", "vendors/ruby"], function(Rational, note, midi, ruby) {
    var root;
    if (typeof global !== "undefined" && global !== null) {
      root = global;
    } else {
      root = window;
    }
    root.rat = function() {
      var args;
      args = 1 <= arguments.length ? __slice.call(arguments, 0) : [];
      return (function(func, args, ctor) {
        ctor.prototype = func.prototype;
        var child = new ctor, result = func.apply(child, args);
        return Object(result) === result ? result : child;
      })(Rational, args, function(){});
    };
    root.RGen = (function() {
      function RGen(dur_occ_obj_arr, streamLen) {
        if (streamLen == null) {
          streamLen = 10;
        }
        this.array = dur_occ_obj_arr || [];
        this.clock = rat(0, 1);
        this.streamLen = streamLen;
      }

      RGen.prototype.add = function(dur_occ_obj) {
        var x, _i, _len, _results;
        if (!dur_occ_obj.length) {
          dur_occ_obj = [dur_occ_obj];
        }
        _results = [];
        for (_i = 0, _len = dur_occ_obj.length; _i < _len; _i++) {
          x = dur_occ_obj[_i];
          this.remove(x.value);
          _results.push(this.array.push(x));
        }
        return _results;
      };

      RGen.prototype.reset = function(dur_occ_objs) {
        console.log("reset gen");
        this.array = [];
        if (dur_occ_objs) {
          return this.add(dur_occ_objs);
        }
      };

      RGen.prototype.reset_clock = function() {
        return this.clock = rat(0, 1);
      };

      RGen.prototype.rvs_sync = function(rvs_table) {
        var _this = this;
        this.reset();
        return _h.each(rvs_table, function(k, v) {
          return _this.add({
            value: rat(1, k),
            occ: v
          });
        });
      };

      RGen.prototype.remove = function(dur) {
        var i, rem_indexes, x, _i, _j, _len, _len1, _ref, _results;
        rem_indexes = [];
        _ref = this.array;
        for (i = _i = 0, _len = _ref.length; _i < _len; i = ++_i) {
          x = _ref[i];
          if (x.value.eq(dur)) {
            rem_indexes.push(i);
          }
        }
        _results = [];
        for (_j = 0, _len1 = rem_indexes.length; _j < _len1; _j++) {
          x = rem_indexes[_j];
          _results.push(this.array.splice(x, 1));
        }
        return _results;
      };

      RGen.prototype.denoms = function() {
        var res;
        res = [];
        this.array.map(function(x) {
          var den, mod, _results;
          mod = 0;
          den = x.value.denom;
          _results = [];
          while (mod === 0) {
            if (res.indexOf(den) === -1) {
              res.push(den);
            }
            mod = den % 2;
            _results.push(den /= 2);
          }
          return _results;
        });
        return res;
      };

      RGen.prototype.next = function(n, plan_offset) {
        var f, result, start_time, _i,
          _this = this;
        result = [];
        start_time = plan_offset || this.clock.toFloat();
        f = function() {
          var available_vals, i, pioche, x, _i, _j, _k, _len, _len1, _ref, _ref1;
          available_vals = [];
          _ref = _this.array;
          for (_i = 0, _len = _ref.length; _i < _len; _i++) {
            x = _ref[_i];
            if (x.occ !== 0) {
              if (_this.denoms().indexOf(x.value.plus(_this.clock).denom) >= 0) {
                available_vals.push(x);
              }
            }
          }
          pioche = [];
          for (_j = 0, _len1 = available_vals.length; _j < _len1; _j++) {
            x = available_vals[_j];
            for (i = _k = 0, _ref1 = x.occ - 1; 0 <= _ref1 ? _k <= _ref1 : _k >= _ref1; i = 0 <= _ref1 ? ++_k : --_k) {
              pioche.push(x.value);
            }
          }
          pioche = _a.shuffle(pioche);
          result.push(pioche[0]);
          return _this.clock.add(pioche[0]);
        };
        for (_i = 1; 1 <= n ? _i <= n : _i >= n; 1 <= n ? _i++ : _i--) {
          f();
        }
        this.plan_next_stream(start_time);
        return this.melodize(result);
      };

      RGen.prototype.plan_next_stream = function(start_time) {
        var at, cb,
          _this = this;
        at = (this.clock.toFloat() - start_time) * 1000;
        cb = function() {
          return _this.next(_this.streamLen);
        };
        return setTimeout(cb, at);
      };

      RGen.prototype.start = function() {
        this.time_origin = window.performance.now();
        this.reset_clock();
        return this.next(this.streamLen, 1);
      };

      RGen.prototype.melodize = function(rythmic_line) {
        var duration, line, n, pitch, vel, _i, _len;
        line = [];
        for (_i = 0, _len = rythmic_line.length; _i < _len; _i++) {
          duration = rythmic_line[_i];
          pitch = Math.floor(Math.random() * 30 + 40);
          vel = Math.floor(Math.random() * 30 + 40);
          n = new Note(pitch, vel, duration);
          line.push(n);
        }
        return this.send_to_midi(line);
      };

      RGen.prototype.send_to_midi = function(line, position) {
        return midi.line({
          notes: line,
          at: this.clock.toFloat() * 1000 + this.time_origin
        });
      };

      RGen.prototype.pause = function() {};

      return RGen;

    })();
    return root.RGen2 = (function() {
      function RGen2(opt) {
        this.array = opt.prob_array || [];
        this.head_position = null;
        this.streamLen = opt.streamLen;
      }

      RGen2.prototype.add = function(dur_occ_obj) {
        var x, _i, _len, _results;
        if (!dur_occ_obj.length) {
          dur_occ_obj = [dur_occ_obj];
        }
        _results = [];
        for (_i = 0, _len = dur_occ_obj.length; _i < _len; _i++) {
          x = dur_occ_obj[_i];
          this.remove(x.value);
          _results.push(this.array.push(x));
        }
        return _results;
      };

      RGen2.prototype.reset = function(dur_occ_objs) {
        console.log("reset gen");
        this.array = [];
        if (dur_occ_objs) {
          return this.add(dur_occ_objs);
        }
      };

      RGen2.prototype.reset_clock = function() {
        return this.clock = rat(0, 1);
      };

      RGen2.prototype.rvs_sync = function(rvs_table) {
        var _this = this;
        this.reset();
        return _h.each(rvs_table, function(k, v) {
          return _this.add({
            value: rat(1, k),
            occ: v
          });
        });
      };

      RGen2.prototype.remove = function(dur) {
        var i, rem_indexes, x, _i, _j, _len, _len1, _ref, _results;
        rem_indexes = [];
        _ref = this.array;
        for (i = _i = 0, _len = _ref.length; _i < _len; i = ++_i) {
          x = _ref[i];
          if (x.value.eq(dur)) {
            rem_indexes.push(i);
          }
        }
        _results = [];
        for (_j = 0, _len1 = rem_indexes.length; _j < _len1; _j++) {
          x = rem_indexes[_j];
          _results.push(this.array.splice(x, 1));
        }
        return _results;
      };

      RGen2.prototype.denoms = function() {
        var res;
        res = [];
        this.array.map(function(x) {
          var den, mod, _results;
          mod = 0;
          den = x.value.denom;
          _results = [];
          while (mod === 0) {
            if (res.indexOf(den) === -1) {
              res.push(den);
            }
            mod = den % 2;
            _results.push(den /= 2);
          }
          return _results;
        });
        return res;
      };

      RGen2.prototype.bang = function(metronome) {
        var r;
        this.origin = metronome.origin_point;
        this.bpm = metronome.bpm;
        this.current_time = metronome.total();
        if (!this.head_position) {
          this.head_position = this.current_time.dup();
        }
        r = this.head_position.minus(this.current_time);
        console.log(r.numer + '/' + r.denom);
        if (this.insertion_point) {
          console.log("insertion" + this.insertion_point.numer + '/' + this.insertion_point.denom);
        }
        if ((this.head_position.minus(this.current_time)).lt(this.streamLen)) {
          this.insertion_point = this.head_position.dup();
          return this.generate();
        }
      };

      RGen2.prototype.generate = function() {
        var results;
        results = [];
        while (this.head_position.minus(this.current_time).lt(this.streamLen)) {
          results.push(this.next());
        }
        if (results) {
          return this.melodize(results);
        }
      };

      RGen2.prototype.next = function() {
        var available_vals, i, pioche, x, _i, _j, _k, _len, _len1, _ref, _ref1;
        available_vals = [];
        _ref = this.array;
        for (_i = 0, _len = _ref.length; _i < _len; _i++) {
          x = _ref[_i];
          if (x.occ !== 0) {
            if (this.denoms().indexOf(x.value.plus(this.head_position).denom) >= 0) {
              available_vals.push(x);
            }
          }
        }
        pioche = [];
        for (_j = 0, _len1 = available_vals.length; _j < _len1; _j++) {
          x = available_vals[_j];
          for (i = _k = 0, _ref1 = x.occ - 1; 0 <= _ref1 ? _k <= _ref1 : _k >= _ref1; i = 0 <= _ref1 ? ++_k : --_k) {
            pioche.push(x.value);
          }
        }
        pioche = _a.shuffle(pioche);
        this.head_position.add(pioche[0]);
        return pioche[0];
      };

      RGen2.prototype.melodize = function(rythmic_line) {
        var duration, line, n, pitch, vel, _i, _len;
        line = [];
        for (_i = 0, _len = rythmic_line.length; _i < _len; _i++) {
          duration = rythmic_line[_i];
          pitch = Math.floor(Math.random() * 30 + 40);
          vel = Math.floor(Math.random() * 30 + 40);
          console.log("test");
          console.log(duration.times(rat(60, this.bpm)));
          n = new Note(pitch, vel, duration.times(rat(60, this.bpm)));
          line.push(n);
        }
        return this.send_to_midi(line);
      };

      RGen2.prototype.send_to_midi = function(line, position) {
        return midi.line({
          notes: line,
          at: this.origin + this.insertion_point.times(rat(60, this.bpm)).toFloat() * 1000
        });
      };

      RGen2.prototype.pause = function() {};

      return RGen2;

    })();
  });

}).call(this);
