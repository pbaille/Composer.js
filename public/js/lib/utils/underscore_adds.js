// Generated by CoffeeScript 1.6.3
(function() {
  var __slice = [].slice;

  define(["vendors/underscore"], function() {
    return _.mixin({
      gcd: function(a, b) {
        var t;
        t = void 0;
        while (b !== 0) {
          t = b;
          b = a % b;
          a = t;
        }
        return a;
      },
      lcm: function(a, b) {
        return a * b / _.gcd(a, b);
      },
      lcmm: function(arr) {
        var arr0;
        if (arr.length === 2) {
          return _.lcm(arr[0], arr[1]);
        } else {
          arr0 = arr.shift();
          return _.lcm(arr0, _.lcmm(arr));
        }
      },
      sum: function(arr) {
        return _.reduce(arr, function(acc, el) {
          return acc += el;
        });
      },
      product: function() {
        var args;
        args = 1 <= arguments.length ? __slice.call(arguments, 0) : [];
        if (_.isArray(args[0])) {
          args = args[0];
        }
        return _.reduce(args, function(a, b) {
          return a * b;
        }, 1);
      },
      factorise: function(numm) {
        var checker, newnum, result;
        if (numm === 1) {
          return [1];
        }
        newnum = numm;
        result = [];
        checker = 2;
        while (checker * checker <= newnum) {
          if (newnum % checker === 0) {
            result.push(checker);
            newnum = newnum / checker;
          } else {
            checker++;
          }
        }
        if (newnum !== 1) {
          result.push(newnum);
        }
        return result;
      },
      sort: function(arr) {
        return arr.sort(10);
      },
      concat: function() {
        var args;
        args = 1 <= arguments.length ? __slice.call(arguments, 0) : [];
        return _.reduce(args, function(acc, el, coll) {
          return acc.concat(el, []);
        });
      },
      wrap_if_not: function(arr) {
        if (!(arr instanceof Array)) {
          arr = [arr];
        }
        return arr;
      },
      reverse: function(coll) {
        return _.reduceRight(coll, function(acc, x) {
          return acc.concat(x);
        }, []);
      },
      rotate: function(coll, step) {
        var head, tail;
        while (step < 0) {
          step += coll.length;
        }
        tail = coll.slice(0, step);
        head = coll.slice(step);
        return head.concat(tail);
      },
      rotations: function(arr) {
        return _.map(arr, function(el, index) {
          return _.rotate(arr, index);
        });
      },
      uniqRotations: function(arr) {
        return _.compose(_.uniq, _.rotations)(arr);
      },
      median: function() {
        var args;
        args = 1 <= arguments.length ? __slice.call(arguments, 0) : [];
        if (_.isArray(args[0])) {
          args = args[0];
        }
        return _.sum(args) / args.length;
      },
      deepUniq: function(coll) {
        var recursive_pick_and_clean, result;
        result = [];
        recursive_pick_and_clean = function(coll2) {
          var equalsFirst, first, newColl, rest;
          rest = _.rest(coll2);
          first = _.first(coll2);
          result.push(first);
          equalsFirst = function(el) {
            return _.isEqual(el, first);
          };
          newColl = _.reject(rest, equalsFirst);
          if (!_.isEmpty(newColl)) {
            return recursive_pick_and_clean(newColl);
          }
        };
        recursive_pick_and_clean(coll);
        return result;
      },
      scale: function(numArray, inMin, inMax, outMin, outMax) {
        var args, inSpan, map_fun, outSpan;
        if (arguments.length === 5) {
          inSpan = inMax - inMin;
          outSpan = outMax - outMin;
          map_fun = function(elem) {
            var valueScaled;
            valueScaled = (elem - inMin) / inSpan;
            return outMin + (valueScaled * outSpan);
          };
          if (_.isArray(numArray)) {
            return _.map(numArray, map_fun);
          } else {
            return map_fun(numArray);
          }
        } else if (arguments.length === 4) {
          args = _.toArray(arguments);
          return function(arr) {
            return _.scale(arr, args[0], args[1], args[2], args[3]);
          };
        }
      },
      tonicize: function(arr) {
        return _(arr).map(function(x, i, c) {
          return (x - c[0] + 12) % 12;
        }).sort();
      },
      tonicized_rotations: function(arr) {
        return _.map(_.rotations(arr), _.tonicize);
      },
      to_functs: function(arr) {
        return _.map(arr, function(i) {
          if (i) {
            return i % 12;
          } else {
            return i;
          }
        });
      },
      combinations: function(arr, p) {
        var combo, combos, i, n;
        if (p === 0) {
          return [[]];
        }
        i = 0;
        n = arr.length;
        combos = [];
        combo = [];
        while (combo.length < p) {
          if (i < n) {
            combo.push(i);
            i += 1;
          } else {
            if (combo.length === 0) {
              break;
            }
            i = combo.pop() + 1;
          }
          if (combo.length === p) {
            combos.push(_.clone(combo));
            i = combo.pop() + 1;
          }
        }
        return _.map(combos, function(x) {
          return _.map(x, function(index) {
            return arr[index];
          });
        });
      },
      unique_permutation: function(coll) {
        var array_copy, e, i, j, l, range, results, rev, size, _i, _j, _len, _ref, _ref1, _ref2, _results;
        array_copy = coll.sort(10);
        results = [];
        results.push(_.clone(array_copy));
        size = _.size(coll);
        if (size < 2) {
          return;
        }
        while (true) {
          j = _.size(coll) - 2;
          while (j > 0 && array_copy[j] >= array_copy[j + 1]) {
            j -= 1;
          }
          if (array_copy[j] < array_copy[j + 1]) {
            l = size - 1;
            while (array_copy[j] >= array_copy[l]) {
              l -= 1;
            }
            _ref = [array_copy[l], array_copy[j]], array_copy[j] = _ref[0], array_copy[l] = _ref[1];
            rev = _.reverse(array_copy);
            range = (function() {
              _results = [];
              for (var _i = _ref1 = j + 1, _ref2 = size - 1; _ref1 <= _ref2 ? _i <= _ref2 : _i >= _ref2; _ref1 <= _ref2 ? _i++ : _i--){ _results.push(_i); }
              return _results;
            }).apply(this);
            for (i = _j = 0, _len = range.length; _j < _len; i = ++_j) {
              e = range[i];
              array_copy[e] = rev[i];
            }
            results.push(_.clone(array_copy));
          } else {
            break;
          }
        }
        return results;
      },
      statusCombination: function(arr) {
        var init, x, _i, _ref;
        init = [];
        for (x = _i = 0, _ref = arr[0]; 0 <= _ref ? _i <= _ref : _i >= _ref; x = 0 <= _ref ? ++_i : --_i) {
          init.push([x]);
        }
        return _.reduce(_.rest(arr), function(final, el, index) {
          var clone, e, _j, _k, _len;
          clone = _.clone(final);
          final = [];
          for (_j = 0, _len = clone.length; _j < _len; _j++) {
            e = clone[_j];
            for (x = _k = 0; 0 <= el ? _k <= el : _k >= el; x = 0 <= el ? ++_k : --_k) {
              final.push(e.concat(x));
            }
          }
          return final;
        }, init);
      },
      comb_zip: function(a) {
        var status_tab;
        status_tab = a.map(function(x) {
          return x.length - 1;
        });
        return _.reduce(_.statusCombination(status_tab), function(final, el, index) {
          final.push(_.map(el, function(x, i) {
            return a[i][x];
          }));
          return final;
        }, []);
      },
      domainPartition: function(dom, size, sum) {
        var arr, domain, results, sumRecursive, _i, _results;
        domain = dom.sort(10);
        results = [];
        arr = _.map((function() {
          _results = [];
          for (var _i = 1; 1 <= size ? _i <= size : _i >= size; 1 <= size ? _i++ : _i--){ _results.push(_i); }
          return _results;
        }).apply(this), function() {
          return 0;
        });
        sumRecursive = function(n, sumSoFar, arr) {
          var dom_bounds, final_arr, i, restricted_dom, start, x, _arr, _j, _k, _len, _len1, _ref, _results1;
          if (n === 1) {
            if (sum - sumSoFar >= arr[arr.length - 2] && domain.indexOf(sum - sumSoFar) >= 0) {
              final_arr = arr.slice(0);
              final_arr[final_arr.length - 1] = sum - sumSoFar;
              return results.push(final_arr);
            }
          } else if (n > 1) {
            if (n !== size) {
              start = arr[arr.length - n - 1];
            } else {
              start = domain[0];
            }
            dom_bounds = [start * (n - 1), domain[domain.length - 1] * (n - 1)];
            restricted_dom = [];
            for (_j = 0, _len = domain.length; _j < _len; _j++) {
              x = domain[_j];
              if (!(x < start)) {
                if ((dom_bounds[0] + x <= (_ref = sum - sumSoFar) && _ref <= dom_bounds[1] + x)) {
                  restricted_dom.push(x);
                }
              }
            }
            _results1 = [];
            for (_k = 0, _len1 = restricted_dom.length; _k < _len1; _k++) {
              i = restricted_dom[_k];
              _arr = arr.slice(0);
              _arr[_arr.length - n] = i;
              _results1.push(sumRecursive(n - 1, sumSoFar + i, _arr));
            }
            return _results1;
          }
        };
        sumRecursive(size, 0, arr);
        return results;
      }
    });
  });

}).call(this);
