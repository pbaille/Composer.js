// Generated by CoffeeScript 1.6.3
(function() {
  define(["vendors/ruby"], function() {
    _a.wrap_if_not = function(arr) {
      if (!(arr instanceof Array)) {
        arr = [arr];
      }
      return arr;
    };
    _a.pick_random_el = function(arr) {
      var rand_index;
      rand_index = Math.floor(Math.random() * arr.length);
      return arr[rand_index];
    };
    _a.scramble = function(_arr) {
      var arr, counter, index, temp;
      arr = _arr.slice(0);
      counter = arr.length;
      temp = void 0;
      index = void 0;
      while (counter--) {
        index = (Math.random() * (counter + 1)) | 0;
        temp = arr[counter];
        arr[counter] = arr[index];
        arr[index] = temp;
      }
      return arr;
    };
    _a.rotations = function(arr) {
      var result, x, _i, _ref;
      result = [];
      for (x = _i = 0, _ref = arr.length - 1; 0 <= _ref ? _i <= _ref : _i >= _ref; x = 0 <= _ref ? ++_i : --_i) {
        result.push(_a.rotate(arr, x));
      }
      return _a.uniq(result);
    };
    _a.median = function(arr) {
      return _a.somme(arr) / arr.length;
    };
    _a.somme = function(arr) {
      return arr.reduce(function(previousValue, currentValue) {
        return previousValue + currentValue;
      });
    };
    _a.tonicize = function(arr) {
      var result,
        _this = this;
      result = arr.map(function(x) {
        return (x - arr[0] + 12) % 12;
      });
      return _a.sort(result);
    };
    _a.tonicized_rotations = function(arr) {
      return _a.rotations(arr).map(function(x) {
        return _a.tonicize(x);
      });
    };
    _a.to_functs = function(arr) {
      return arr.map(function(i) {
        if (i) {
          return i % 12;
        } else {
          return i;
        }
      });
    };
    RubyJS.Array.prototype.unique_permutation = function() {
      var array_copy, e, i, j, l, range, results, rev, temp, _i, _j, _len, _ref, _ref1, _results;
      array_copy = this.sort();
      results = [];
      results.push(array_copy.dup().value());
      if (this.size() < 2) {
        return;
      }
      while (true) {
        j = this.size() - 2;
        while (j > 0 && array_copy.get(j) >= array_copy.get(j + 1)) {
          j -= 1;
        }
        if (array_copy.get(j) < array_copy.get(j + 1)) {
          l = this.size() - 1;
          while (array_copy.get(j) >= array_copy.get(l)) {
            l -= 1;
          }
          temp = array_copy.get(j);
          array_copy.set(j, array_copy.get(l));
          array_copy.set(l, temp);
          rev = array_copy.dup().reverse();
          range = (function() {
            _results = [];
            for (var _i = _ref = j + 1, _ref1 = this.size() - 1; _ref <= _ref1 ? _i <= _ref1 : _i >= _ref1; _ref <= _ref1 ? _i++ : _i--){ _results.push(_i); }
            return _results;
          }).apply(this);
          for (i = _j = 0, _len = range.length; _j < _len; i = ++_j) {
            e = range[i];
            array_copy.set(e, rev.get(i));
          }
          results.push(array_copy.dup().value());
        } else {
          break;
        }
      }
      return results;
    };
    _a.statusCombination = function(arr) {
      var i, int, it, item, result, temp, x, _i, _j, _k, _l, _len, _len1;
      result = [];
      temp = [];
      for (_i = 0, _len = arr.length; _i < _len; _i++) {
        x = arr[_i];
        result = [];
        if (temp.length === 0) {
          for (i = _j = 0; 0 <= x ? _j <= x : _j >= x; i = 0 <= x ? ++_j : --_j) {
            result.push([i]);
          }
        } else {
          for (int = _k = 0; 0 <= x ? _k <= x : _k >= x; int = 0 <= x ? ++_k : --_k) {
            for (_l = 0, _len1 = temp.length; _l < _len1; _l++) {
              item = temp[_l];
              it = item.concat(int);
              result.push(it);
            }
          }
        }
        temp = result.slice(0);
      }
      return result;
    };
    return _a.comb_zip = function(a) {
      var results, status_tab, x, _i, _len, _ref;
      results = [];
      status_tab = a.map(function(x) {
        return x.length - 1;
      });
      _ref = _a.statusCombination(status_tab);
      for (_i = 0, _len = _ref.length; _i < _len; _i++) {
        x = _ref[_i];
        results.push(x.map(function(y, i) {
          return a[i][y];
        }));
      }
      return results;
    };
  });

}).call(this);
